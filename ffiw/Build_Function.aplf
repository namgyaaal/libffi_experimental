 r←Build_Function(name def ret)
 ns←'##.ffiw.ex.'
 ⎕IO←0
 names←0⌷⍉def
 ti←1⌷⍉def
 _←ex.FFIW_BuildFunction name(ti)(≢ti)ret
 ⍝ note ⍵-1, ¯1+1⌷⍵ in function due to first type being void
 ⍝ we want to check for it but at same time ignore it when
 ⍝  selecting from write_names/read_names

 ⍝ old non-struct building for reference
 ⍝build_fn←{
 ⍝     ⍝ If it's above it's a struct, handle recursively?
 ⍝    ⍵>≢types.raw:0 ⍝ COVER SOON
 ⍝    ⊃⍺[⍵-1]
 ⍝}

 ⍝ Unroll definition in (⍺) recursive table form of
 ⍝ N×2, where first column is names and second column is either
 ⍝ (1) types
 ⍝ (2) submatrix of (⍺)
 unroll←{
     ⍝ Handle char fields
     (tn ti)←({⍵≡0:(,⍵) ⋄ ⍵}¨0⌷⍉⍵)(1⌷⍉⍵)
     tbli←0⌷⍉types.type_table
     tblv←1⌷⍉types.type_table
     (≢ti)≠≢∊(⍸tbli=⊢)¨ti:{
         ⎕←'Error: ',name,' using undefined types' ⋄ ⎕SIGNAL 8
     }⍬
     v←{0=≡⍵:⍵ ⋄ unroll ⍵}¨tblv[(⍸tbli=⊢)¨ti]
     ⍉↑tn v
 }
 ⍝ Merge as a string with ∇, : for enlisting and then splitting
 parse_unit←{
     ⍺ ← ('ns' types.write_names)
     (ns fns) ← ⍺

     base←fns[¯1+1⌷⍵]
     ⍝ dorito and colon as seperators when enlisting
     ∊'∇',⍨base,':',ns,'.',⊃⍵
 }
 roll_ns←{
     ⍺ ← (types.write_names 'ns' '')
     (fn_names ns pre) ← ⍺
     ⍝ base case: (name scalar_type)
     ⍝ prefix name and then parse the unit
     1=≡⍵: (ns fn_names)∘parse_unit⍤({⊂1↓pre,'.',⊃⍵}@0)⍵
     pr←pre,'.',⊃⍵
     (fn_names ns pr)∘∇¨↓1⊃⍵
 }

 get_struct_fields ← {(⊂⍤⍋⍛⌷)∪⊃,/{¯1↓¨,\¯1↓1↓'.',⍨¨'.'∘(≠⊆⊢)1⊃⍵}¨⍵}


 step←unroll def
 step←∊roll_ns¨↓step

 ⍝ Vector with elements (FFIW_* ns.*)
 write_fns←':'∘(≠⊆⊢)¨'∇'(≠⊆⊢)step

 ⍝ If structs don't exist, set so that ⎕VGET for fields works
 sfields←get_struct_fields write_fns
 ⍝sfields←(⊂⍤⍋⍛⌷)∪⊃,/{¯1↓¨,\¯1↓1↓'.',⍨¨'.'∘(≠⊆⊢)1⊃⍵}¨write_fns
 sfields←{'ns.',⍵,' ← ns.⎕VGET ⊂(,''',⍵,''') ()'}¨sfields

 ⍝ whitespaces get printed without _ ←
 ⍝ shy returns? just don't know where
 write_fns←{'_ ← ##.ffiw.ex.',(⊃⍵),' ns.⎕VGET ⊂(,''',(3↓1⊃⍵),''') 0'}¨write_fns

 get_read_fns ← {
     ⍺ ← types.read_names
     0≡⍵: ⊂'r←0'

     ⍝ Everything beyond this is a struct
     ⍝ (Ignoring ptr, TODO)
     ⍵<≢⍺: ⊂'r← ⊃', ns, '⍬',⍨⊃⍺[⍵-2]

     idx ← ⍵⍳⍨(0⌷⍉types.type_table)
     out ←⊂ 'r←()'
     step ← ∊(⍺ 'r' '')∘roll_ns¨↓unroll idx⊃1⌷⍉types.type_table
     read_fns ← ':'∘(≠⊆⊢)¨'∇'(≠⊆⊢)step
     sfields←get_struct_fields read_fns

     out,← {'r.', ⍵, ' ← ()'}¨ sfields
     out,← {(1⊃⍵), ' ← ⊃', ns, (⊃⍵), '⍬'}¨read_fns
     out
 }
 read_fns ← get_read_fns ret

 ⍝ Old non-struct one for reference
 ⍝write_fns←types.write_names∘build_fn¨ti
 ⍝write_fns←('_←',ns)∘,¨write_fns,¨' ns⎕VGET ⊂(,'''∘,¨{⍵,''') 0'}¨names

 ⍝ Non-struct return code
 ⍝read_fns ← ⊂get_read_fns ret
 ⍝⎕ ← read_fns
 ⍝read_fn←'r←',∊types.read_names{⍵=0:'0' ⋄ '⊃',ns,'⍬',⍨⊃⍺[⍵-1]}ret
 compose←⍬
 compose←compose,⊂(name{⍵≡types.void:'∇',⍺,' ns;b;r' ⋄ '∇r←',⍺,' ns;b'}ret)
 compose←compose,sfields
 compose←compose,⊂'b←',ns,'FFIW_SetTarget ⊂''',name,''''
 compose←compose,write_fns
 compose←compose,⊂'_←',ns,'FFIW_Call⍬'
 compose←compose,read_fns
 compose←compose,'∇'
 r←compose
